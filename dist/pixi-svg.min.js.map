{"version":3,"sources":["node_modules/pixify/node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/d-path-parser/parser.js","src/SVG.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiSvg","min","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","root","factory","dPathParse","d","makeCommand","obj","cmd","relative","get","what","must","re","lastIndex","index","res","exec","getSequence","matched","sequence","matchers","push","command","number","comma","flag","coordinate pair","x","y","arc definition","radii","rotation","large","clockwise","end","commands","upcmd","toUpperCase","map","coords","reduce","seq","rest","cp1","cp","value","apply","_dPathParser","measureColor","document","createElement","SVG","svg","_classCallCheck","_this","_possibleConstructorReturn","_PIXI$Graphics","fill","svgChildren","children","inherit","arguments","undefined","child","nodeName","toLowerCase","svgPath","svgCircle","svgRect","hex","substr","parseInt","style","color","rgb","getComputedStyle","body","appendChild","match","removeChild","isEllipse","heightProp","widthProp","width","parseFloat","node","getAttribute","height","cx","cy","drawEllipse","drawCircle","rx","drawRoundedRect","drawRect","strokeWidth","lineWidth","lineColor","stroke","hexToUint","beginFill","opacity","lineStyle","prototype","_dPathParser2","default","moveTo","lineTo","closePath","currX","currY","bezierCurveTo","cp2","_currX","_currY","_currX2","_currY2","quadraticCurveTo","_currX3","_currY3","PIXI","Graphics","d-path-parser","3","__esModule","_SVG","_SVG2"],"mappings":";;;;;;;CAAA,SAAAA,GAAA,GAAA,gBAAAC,UAAA,mBAAAC,QAAAA,OAAAD,QAAAD,QAAA,IAAA,kBAAAG,SAAAA,OAAAC,IAAAD,UAAAH,OAAA,CAAA,GAAAK,EAAAA,GAAA,mBAAAC,QAAAA,OAAA,mBAAAC,QAAAA,OAAA,mBAAAC,MAAAA,KAAAC,MAAAJ,EAAAK,UAAAL,EAAAK,aAAAC,IAAAX,MAAA,WAAA,GAAAG,EAAA,OAAA,SAAAS,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAjB,GAAA,GAAAsB,OAAA,uBAAAL,EAAA,IAAA,MAAAjB,GAAAuB,KAAA,mBAAAvB,EAAA,GAAAwB,GAAAV,EAAAG,IAAAhB,WAAAY,GAAAI,GAAA,GAAAQ,KAAAD,EAAAvB,QAAA,SAAAW,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,GAAAF,IAAAY,EAAAA,EAAAvB,QAAAW,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAhB,QAAA,IAAA,GAAAoB,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAW,GAAA,SAAAP,EAAAlB,EAAAD,ICUA,SAAA2B,EAAAC,GACA,kBAAA1B,IAAAA,EAAAC,IAEAD,KAAA0B,GACA,gBAAA5B,GAIAC,EAAAD,QAAA4B,IAGAD,EAAAE,WAAAD,KAEApB,KAAA,WACA,YAEA,OAAA,UAAAsB,GAgHA,QAAAC,GAAAC,GAIA,MAHAA,GAAAV,KAAAW,EACAD,EAAAE,SAAAA,EAEAF,EAEA,QAAAG,GAAAC,EAAAC,GACAC,EAAAF,GAAAG,UAAAC,CACA,IAAAC,GAAAH,EAAAF,GAAAM,KAAAZ,EACA,KAAAW,GAAAA,EAAAD,QAAAA,EAAA,CACA,IAAAH,EAAA,MAAA,KACA,MAAAhB,OAAA,YAAAe,EAAA,gBAAAI,GAKA,MAFAA,GAAAF,EAAAF,GAAAG,UAEAE,EAAA,GAEA,QAAAE,GAAAP,GAIA,IAHA,GACAQ,GADAC,KAEAR,GAAA,EACAO,EAAAE,EAAAV,GAAAC,IACAQ,EAAAE,KAAAH,GACAP,IAAAF,EAAA,QAGA,OAAAU,GAlGA,IAxCA,GAAAP,IACAU,QAAA,sBACAC,OAAA,sCACAC,MAAA,iBACAC,KAAA,cAEAL,GACAG,OAAA,SAAAZ,GACA,OAAAF,EAAA,SAAAE,IAEAe,kBAAA,SAAAf,GACA,GAAAgB,GAAAlB,EAAA,SAAAE,EACA,OAAA,QAAAgB,GAAAhB,GACAF,EAAA,UAEAkB,GAAAA,EAAAC,GADAnB,EAAA,UAAA,KAFA,MAKAoB,iBAAA,SAAAlB,GACA,GAAAmB,GAAAV,EAAA,mBAAAT,EACA,KAAAmB,IAAAnB,EAAA,MAAA,KACAF,GAAA,QACA,IAAAsB,IAAAtB,EAAA,UAAA,EACAA,GAAA,SAAA,EACA,IAAAuB,MAAAvB,EAAA,QAAA,EACAA,GAAA,QACA,IAAAwB,MAAAxB,EAAA,QAAA,EAGA,OAFAA,GAAA,UAGAqB,MAAAA,EACAC,SAAAA,EACAC,MAAAA,EACAC,UAAAA,EACAC,IANAd,EAAA,oBAAA,MAUAN,EAAA,EACAqB,KAEArB,EAAAV,EAAAL,QAAA,CACA,GAGAoB,GAHAZ,EAAAE,EAAA,WACA2B,EAAA7B,EAAA8B,cACA7B,EAAAD,IAAA6B,CAEA,QAAAA,GACA,IAAA,IACAjB,EAAAF,EAAA,mBAAAqB,IAAA,SAAAC,EAAA7C,GAEA,MADA,KAAAA,IAAAa,EAAAC,EAAA,IAAA,KACAH,GAAA6B,IAAAK,KAEA,MACA,KAAA,IACA,IAAA,IACApB,EAAAF,EAAA,mBAAAqB,IAAA,SAAAC,GACA,MAAAlC,IAAA6B,IAAAK,KAEA,MACA,KAAA,IAEA,GADApB,EAAAF,EAAA,mBACAE,EAAApB,OAAA,EACA,KAAAJ,OAAA,gDAAAmB,EAEAK,GAAAA,EAAAqB,OAAA,SAAAC,EAAAF,EAAA7C,GACA,GAAAgD,GAAAhD,EAAA,CACA,IAAAgD,EAEA,CACAD,EAAAA,EAAA1C,OAAA,GACA,IAAA2C,EAAA,MAAA,OAAAH,MAHAE,GAAApB,KAAAhB,GAAAsC,IAAAJ,IAKA,OAAAE,OAGA,MACA,KAAA,IACA,IAAA,IAEA,GADAtB,EAAAF,EAAA,mBACA,EAAAE,EAAApB,OACA,KAAAJ,OAAA,+CAAAmB,EAEAK,GAAAA,EAAAqB,OAAA,SAAAC,EAAAF,EAAA7C,GACA,EAAAA,EAIA+C,EAAAA,EAAA1C,OAAA,GACAmC,IAAAK,EAHAE,EAAApB,KAAAhB,GAAAuC,GAAAL,IAKA,OAAAE,OAGA,MACA,KAAA,IACA,IAAA,IACAtB,EAAAF,EAAA,UAAAqB,IAAA,SAAAO,GACA,MAAAxC,IAAAwC,MAAAA,KAEA,MACA,KAAA,IACA1B,EAAAF,EAAA,kBAAAqB,IAAAjC,EACA,MACA,KAAA,IACAc,IAAAvB,KAAA,MAGAuC,EAAAd,KAAAyB,MAAAX,EAAAhB,GAGA,MAAAgB,snBCxIA,IAAAY,GAAAtD,EAAA,wEAIMuD,EAAeC,SAASC,cAAc,OASvBC,cAIjB,QAAAA,GAAaC,GAAKC,EAAAvE,KAAAqE,EAAA,IAAAG,GAAAC,EAAAzE,KACd0E,EAAA1D,KAAAhB,MADc,OAEdwE,GAAKG,KAAKL,GACVE,EAAKI,YAAYN,EAAIO,UAHPL,EAwRI,0BA3QtBI,qBAAaC,GACT,IAAK,GADcC,GAAiBC,UAAA9D,OAAA,OAAA+D,KAAAD,UAAA,IAAAA,UAAA,GAC3BnE,EAAI,EAAGA,EAAIiE,EAAS5D,OAAQL,IAAK,CACtC,GAAMqE,GAAQJ,EAASjE,EAEvB,QADAZ,KAAK2E,KAAKM,EAAOH,GACTG,EAAMC,SAASC,eACnB,IAAK,OACDnF,KAAKoF,QAAQH,EACb,MAEJ,KAAK,SACL,IAAK,UACDjF,KAAKqF,UAAUJ,EACf,MAEJ,KAAK,OACDjF,KAAKsF,QAAQL,GAUbjF,KAAA4E,YAAAK,EAAAJ,UAAA,qDAkBR,SANRU,EAAAC,UAGQ,IAAAD,EAAMtE,6CAGFwE,SAAAF,EAAJ,GAECrB,GAAAwB,MAAAC,MAAAJ,CACD,IAAAK,GAAO/F,OAASgG,iBAAhB1B,SAAA2B,KAAAC,YAAA7B,IAAAyB,MAAAK,MAAA,QAAAxC,IAAA,SAAA9C,GACG,MAAA+E,UAAA/E,EAAA,KAKK,OAHRyD,UAAM2B,KAAMG,YAAO/B,IAGX0B,EAAO,IAAA,KAAAA,EAAP,IAAA,GAAAA,EAAA,kDAahB,2BAEQM,KACAC,GAAY,IACVC,GAAY,IAEd,IAAAC,GAAAC,WAAAC,EAAAC,aAAAJ,IACAK,EAAAH,WAAAC,EAAAC,aAAAL,IACHO,EAAAH,EAAAC,aAAA,MACKG,EAAAJ,EAAQC,aAAW,MACnB3D,EAAA,EACAC,EAAA,CACK,QAAL4D,IACF7D,EAAIyD,WAARI,IAEW,OAAPC,IACA7D,EAAIwD,WAAWK,IAEfT,EAGAlG,KAAC4G,YAAW/D,EAAAC,EAAAuD,EAAAI,GAFZzG,KAAI6G,WAAWhE,EAAfC,EAAAuD,8GAgBRC,oCACUG,EAAIH,WAAgBC,EAAAC,aAA1B,WACMM,EAAIR,WAAWC,EAAKC,aAAa,MACjCM,GACA9G,KAAA+G,gBAAoBlE,EAAAC,EAAKuD,EAAAI,EAAaK,GAExC9G,KAAIgH,SAAAnE,EAAAC,EAAAuD,EAAAI,8FAyBZF,eAAM,UACIU,EAAYV,EAAAC,aAAlB,gBACMU,EAA4B,OAAlBD,EAAkBX,WAAlCW,GAAA,EACME,EAAc,OAALC,EAAkBpH,KAAlBqH,UAAfD,GAAApH,KAAAmH,SACMxC,GACY,SAAZA,EACA3E,KAAAsH,UAAY,EAAA,GAEVtH,KAAAsH,UAAJtH,KAAqBqH,UAAA1C,GAAA,OAAA4C,EAAAjB,WAAAiB,GAAA,GAEdzC,GACH9E,KAAAsH,UAAK,GAKZtH,KATDwH,UASYN,EAASC,IAcpB9C,EAAAoD,UAAArC,QAAA,SAAAmB,UACGjF,GAAAiF,EAAKC,aAAa,KAClB3D,MAAA,GACHC,MAAA,GACDO,GAAA,EAAAqE,EAAAC,SAAArG,iCAGJ,QAAAkB,EAAA1B,+DAMmBd,KAAA4H,OAAa/E,EAA5BL,EAAAY,IAAAP,EAAAC,EAAAN,EAAAY,IAAAN,EACA,MACM,KAAA,IAEI9C,KAAU6H,OAAAhF,EAAhBL,EAAAuB,MAAAjB,EACQ,MACM,KAAA,IAKN9C,KAAA6H,OAAAhF,GAAAL,EAAAuB,MAAAjB,EACH,MACS,KAAA,IAKN9C,KAAA6H,OAAAhF,EAAAC,EAAAN,EAAAuB,MACH,MACS,KAAA,IAEN/D,KAAA6H,OAAAhF,EAAAC,GAAAN,EAAAuB,MACH,MACS,KAAA,IAEN/D,KAAA8H,WACH,MACS,KAAA,IAEN9H,KAAA6H,OAAAhF,EAAAL,EAAAY,IAAAP,EAAAC,EAAAN,EAAAY,IAAAN,EACH,MACS,KAAA,IAEN9C,KAAA6H,OAAAhF,GAAAL,EAAAY,IAAAP,EAAAC,GAAAN,EAAAY,IAAAN,EACH,MACS,KAAA,IAEN,GAAAiF,GAAAlF,EACHmF,EAAAlF,CACD9C,MAAAiI,cAAAF,EAAAvF,EAAAqB,IAAAhB,EAAAmF,EAAAxF,EAAAqB,IAAAf,EAAAiF,EAAAvF,EAAA0F,IAAArF,EAAAmF,EAAAxF,EAAA0F,IAAApF,EAAAD,EAAAL,EAAAY,IAAAP,EAAAC,EAAAN,EAAAY,IAAAN,EAAU,MAKN,KAAA,IAEJ,GAAAqF,GAAAtF,EAAUuF,EAAAtF,CACN9C,MAAKiI,cACIE,EAAA3F,EACLqB,IAAKhB,EAAAuF,EAFT5F,EAAAqB,IAAAf,EAAAqF,EAAA3F,EAAA0F,IAAArF,EAAAuF,EAAA5F,EAAA0F,IAAApF,EAAAD,GAAAL,EAAAY,IAAAP,EAAAC,GAAAN,EAAAY,IAAAN,EAIA,MAEJ,KAAK,IAAK,IAAA,IAEN,GAAMuF,GAANxF,EACAyF,EAAKxF,CAQL9C,MAAAuI,iBAAAF,EAAA7F,EAAAsB,GAAAjB,EAAAyF,EAAA9F,EAAAsB,GAAAhB,EAAAD,GAAAL,EAAAY,IAAAP,EAAAC,GAAAN,EAAAY,IAAAN,EACH,MACS,KAAA,IACN,IAAA,IAEA,GAAA0F,GAAK3F,EAQL4F,EAAA3F,CACH9C,MAAAuI,iBAAAC,EAAAhG,EAAAsB,GAAAjB,EAAA4F,EAAAjG,EAAAsB,GAAAhB,EAAAD,EAAAL,EAAAY,IAAAP,EAAAC,EAAAN,EAAAY,IAAAN,MAcSuB,GACNqE,KAAAC,SAEAnJ,GAAAmI,QAAAtD,IAOHuE,gBAAA,IAAAC,GAAA,SAAAlI,EAAAlB,EAAAD,GACD,YACIA,GAAAsJ,YAAA,CAEA,IAAAC,GAAApI,EAAA,SAEHqI,EAER,SAAAxH,GAAA,MAAAA,IAAAA,EAAAsH,WAAAtH,GAAAmG,QAAAnG,IAFQuH,+BA5SgB,KAAK","file":"pixi-svg.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*!\n * d-path-parser - v1.0.0\n * by Massimo Artizzu (MaxArt2501)\n *\n * https://github.com/MaxArt2501/d-path-parser\n *\n * Licensed under the MIT License\n * See LICENSE for details\n */\n\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof exports === \"object\") {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.dPathParse = factory();\n    }\n})(this, function() {\n\"use strict\";\n\nreturn function parse(d) {\n    var re = {\n        command: /\\s*([achlmqstvz])/gi,\n        number: /\\s*([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/gi,\n        comma: /\\s*(?:(,)|\\s)/g,\n        flag: /\\s*([01])/g\n    };\n    var matchers = {\n        \"number\": function(must) {\n            return +get(\"number\", must);\n        },\n        \"coordinate pair\": function(must) {\n            var x = get(\"number\", must);\n            if (x === null && !must) return null;\n            get(\"comma\");\n            var y = get(\"number\", true);\n            return { x: +x, y: +y };\n        },\n        \"arc definition\": function(must) {\n            var radii = matchers[\"coordinate pair\"](must);\n            if (!radii && !must) return null;\n            get(\"comma\");\n            var rotation = +get(\"number\", true);\n            get(\"comma\", true);\n            var large = !!+get(\"flag\", true);\n            get(\"comma\");\n            var clockwise = !!+get(\"flag\", true);\n            get(\"comma\");\n            var end = matchers[\"coordinate pair\"](true);\n            return {\n                radii: radii,\n                rotation: rotation,\n                large: large,\n                clockwise: clockwise,\n                end: end\n            };\n        }\n    }\n    var index = 0;\n    var commands = [];\n\n    while (index < d.length) {\n        var cmd = get(\"command\");\n        var upcmd = cmd.toUpperCase();\n        var relative = cmd !== upcmd;\n        var sequence;\n        switch (upcmd) {\n            case \"M\":\n                sequence = getSequence(\"coordinate pair\").map(function(coords, i) {\n                    if (i === 1) cmd = relative ? \"l\" : \"L\";\n                    return makeCommand({ end: coords });\n                });\n                break;\n            case \"L\":\n            case \"T\":\n                sequence = getSequence(\"coordinate pair\").map(function(coords) {\n                    return makeCommand({ end: coords });\n                });\n                break;\n            case \"C\":\n                sequence = getSequence(\"coordinate pair\");\n                if (sequence.length % 3)\n                    throw Error(\"Expected coordinate pair triplet at position \" + index);\n\n                sequence = sequence.reduce(function(seq, coords, i) {\n                    var rest = i % 3;\n                    if (!rest) {\n                        seq.push(makeCommand({ cp1: coords }));\n                    } else {\n                        var last = seq[seq.length - 1];\n                        last[rest === 1 ? \"cp2\" : \"end\"] = coords;\n                    }\n                    return seq;\n                }, []);\n\n                break;\n            case \"Q\":\n            case \"S\":\n                sequence = getSequence(\"coordinate pair\");\n                if (sequence.length & 1)\n                    throw Error(\"Expected coordinate pair couple at position \" + index);\n\n                sequence = sequence.reduce(function(seq, coords, i) {\n                    var odd = i & 1;\n                    if (!odd) {\n                        seq.push(makeCommand({ cp: coords }));\n                    } else {\n                        var last = seq[seq.length - 1];\n                        last.end = coords;\n                    }\n                    return seq;\n                }, []);\n\n                break;\n            case \"H\":\n            case \"V\":\n                sequence = getSequence(\"number\").map(function(value) {\n                    return makeCommand({ value: value });\n                });\n                break;\n            case \"A\":\n                sequence = getSequence(\"arc definition\").map(makeCommand);\n                break;\n            case \"Z\":\n                sequence = [ { code: \"Z\" } ];\n                break;\n        }\n        commands.push.apply(commands, sequence);\n    }\n\n    return commands;\n\n    function makeCommand(obj) {\n        obj.code = cmd;\n        obj.relative = relative;\n\n        return obj;\n    }\n    function get(what, must) {\n        re[what].lastIndex = index;\n        var res = re[what].exec(d);\n        if (!res || res.index !== index) {\n            if (!must) return null;\n            throw Error(\"Expected \" + what + \" at position \" + index);\n        }\n\n        index = re[what].lastIndex;\n\n        return res[1];\n    }\n    function getSequence(what) {\n        var sequence = [];\n        var matched;\n        var must = true;\n        while (matched = matchers[what](must)) {\n            sequence.push(matched);\n            must = !!get(\"comma\");\n        }\n\n        return sequence;\n    }\n};\n});\n","import dPathParse from 'd-path-parser';\n\n// <div> element to measure string colors like \"black\"\n// and convert to hex colors\nconst measureColor = document.createElement('div');\n\n/**\n * Scalable Graphics drawn from SVG image document.\n * @class SVG\n * @extends PIXI.Graphics\n * @memberof PIXI\n * @param {SVGSVGElement} svg - SVG Element `<svg>`\n */\nexport default class SVG extends PIXI.Graphics {\n    /**\n     * Constructor\n     */\n    constructor (svg) {\n        super();\n        this.fill(svg);\n        this.svgChildren(svg.children);\n    }\n\n    /**\n     * Create a PIXI Graphic from SVG element\n     * @private\n     * @method PIXI.SVG#svgChildren\n     * @param {Array<*>} children - Collection of SVG nodes\n     * @param {Boolean} [inherit=false] Whether to inherit fill settings.\n     */\n    svgChildren (children, inherit = false) {\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            this.fill(child, inherit);\n            switch (child.nodeName.toLowerCase()) {\n                case 'path': {\n                    this.svgPath(child);\n                    break;\n                }\n                case 'circle':\n                case 'ellipse': {\n                    this.svgCircle(child);\n                    break;\n                }\n                case 'rect': {\n                    this.svgRect(child);\n                    break;\n                }\n                case 'g': {\n                    break;\n                }\n                default: {\n                    // @if DEBUG\n                    console.info('[SVGUtils] <%s> elements unsupported', child.nodeName);\n                    // @endif\n                    break;\n                }\n            }\n            this.svgChildren(child.children, true);\n        }\n    }\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @private\n     * @method PIXI.SVG#hexToUint\n     */\n    hexToUint (hex) {\n        if (hex[0] === '#') {\n                        // Remove the hash\n            hex = hex.substr(1);\n\n                        // Convert shortcolors fc9 to ffcc99\n            if (hex.length === 3) {\n                hex = hex.replace(/([a-f0-9])/ig, '$1$1');\n            }\n            return parseInt(hex, 16);\n        } else {\n            measureColor.style.color = hex;\n            const rgb = window.getComputedStyle(document.body.appendChild(measureColor)).color\n                .match(/\\d+/g)\n                .map(function (a) {\n                    return parseInt(a, 10);\n                });\n            document.body.removeChild(measureColor);\n            return (rgb[0] << 16) + (rgb[1] << 8) + rgb[2];\n        }\n    }\n\n    /**\n     * Render a <ellipse> element or <circle> element\n     * @private\n     * @method PIXI.SVG#internalEllipse\n     * @param {SVGCircleElement} node\n     */\n    svgCircle (node) {\n\n        let heightProp = 'r';\n        let widthProp = 'r';\n        const isEllipse = node.nodeName === 'elipse';\n        if (isEllipse) {\n            heightProp += 'x';\n            widthProp += 'y';\n        }\n        const width = parseFloat(node.getAttribute(widthProp));\n        const height = parseFloat(node.getAttribute(heightProp));\n        const cx = node.getAttribute('cx');\n        const cy = node.getAttribute('cy');\n        let x = 0;\n        let y = 0;\n        if (cx !== null) {\n            x = parseFloat(cx);\n        }\n        if (cy !== null) {\n            y = parseFloat(cy);\n        }\n        if (!isEllipse) {\n            this.drawCircle(x, y, width);\n        }\n        else {\n            this.drawEllipse(x, y, width, height);\n        }\n    }\n\n    /**\n     * Render a <rect> element\n     * @private\n     * @method PIXI.SVG#svgRect\n     * @param {SVGRectElement} node\n     */\n    svgRect (node) {\n        const x = parseFloat(node.getAttribute('x'));\n        const y = parseFloat(node.getAttribute('y'));\n        const width = parseFloat(node.getAttribute('width'));\n        const height = parseFloat(node.getAttribute('height'));\n        const rx = parseFloat(node.getAttribute('rx'));\n        if (rx) {\n            this.drawRoundedRect(\n                x,\n                y,\n                width,\n                height,\n                rx\n            );\n        } else {\n            this.drawRect(\n                x,\n                y,\n                width,\n                height\n            );\n        }\n    }\n\n    /**\n     * Set the fill and stroke style.\n     * @private\n     * @method PIXI.SVG#fill\n     * @param {SVGElement} node\n     * @param {Boolean} inherit\n     */\n    fill (node, inherit) {\n        const fill = node.getAttribute('fill');\n        const opacity = node.getAttribute('opacity');\n        const stroke = node.getAttribute('stroke');\n        const strokeWidth = node.getAttribute('stroke-width');\n        const lineWidth = strokeWidth !== null ? parseFloat(strokeWidth) : 0;\n        const lineColor = stroke !== null ? this.hexToUint(stroke) : this.lineColor;\n        if (fill) {\n            if (fill === 'none') {\n                this.beginFill(0, 0);\n            } else {\n                this.beginFill(\n                    this.hexToUint(fill),\n                    opacity !== null ? parseFloat(opacity) : 1\n                );\n            }\n        } else if (!inherit) {\n            this.beginFill(0);\n        }\n        this.lineStyle(\n            lineWidth,\n            lineColor\n        );\n\n        // @if DEBUG\n        if (node.getAttribute('stroke-linejoin')) {\n            console.info('[SVGUtils] \"stroke-linejoin\" attribute is not supported');\n        }\n        if (node.getAttribute('stroke-linecap')) {\n            console.info('[SVGUtils] \"stroke-linecap\" attribute is not supported');\n        }\n        if (node.getAttribute('fill-rule')) {\n            console.info('[SVGUtils] \"fill-rule\" attribute is not supported');\n        }\n        // @endif\n    }\n\n    /**\n     * Render a <path> d element\n     * @method PIXI.SVG#svgPath\n     * @param {SVGPathElement} node\n     */\n    svgPath (node) {\n        const d = node.getAttribute('d');\n        let x, y;\n        const commands = dPathParse(d);\n        for (var i = 0; i < commands.length; i++) {\n            const command = commands[i];\n            switch (command.code) {\n                case 'm': {\n                    this.moveTo(\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 'M': {\n                    this.moveTo(\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                case 'H': {\n                    this.lineTo(x = command.value, y);\n                    break;\n                }\n                case 'h': {\n                    this.lineTo(x += command.value, y);\n                    break;\n                }\n                case 'V': {\n                    this.lineTo(x, y = command.value);\n                    break;\n                }\n                case 'v': {\n                    this.lineTo(x, y += command.value);\n                    break;\n                }\n                case 'Z': {\n                    this.closePath();\n                    break;\n                }\n                case 'L': {\n                    this.lineTo(\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                case 'l': {\n                    this.lineTo(\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 'C': {\n                    const currX = x;\n                    const currY = y;\n                    this.bezierCurveTo(\n                        currX + command.cp1.x,\n                        currY + command.cp1.y,\n                        currX + command.cp2.x,\n                        currY + command.cp2.y,\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                case 'c': {\n                    const currX = x;\n                    const currY = y;\n                    this.bezierCurveTo(\n                        currX + command.cp1.x,\n                        currY + command.cp1.y,\n                        currX + command.cp2.x,\n                        currY + command.cp2.y,\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 's':\n                case 'q': {\n                    const currX = x;\n                    const currY = y;\n                    this.quadraticCurveTo(\n                        currX + command.cp.x,\n                        currY + command.cp.y,\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 'S':\n                case 'Q': {\n                    const currX = x;\n                    const currY = y;\n                    this.quadraticCurveTo(\n                        currX + command.cp.x,\n                        currY + command.cp.y,\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                default: {\n                    // @if DEBUG\n                    console.info('[SVGUtils] Draw command not supported:', command.code, command);\n                    // @endif\n                    break;\n                }\n            }\n        }\n    }\n}\n"],"sourceRoot":"."}