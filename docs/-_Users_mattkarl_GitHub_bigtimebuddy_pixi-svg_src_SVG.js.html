<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>pixi-svg</title>
    
    <meta name="description" content="SVG to Graphics DisplayObject for PIXI" />
    
        <meta name="keywords" content="PixiJS, Rendering, Graphics, SVG, Vector" />
        <meta name="keyword" content="PixiJS, Rendering, Graphics, SVG, Vector" />
    
    
    
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Libre+Franklin:400,700" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/main.css">

    
    <script>
    var config = {"monospaceLinks":false,"cleverLinks":false,"applicationName":"pixi-svg","meta":{"title":"pixi-svg","description":"SVG to Graphics DisplayObject for PIXI","keyword":"PixiJS, Rendering, Graphics, SVG, Vector"},"linenums":true,"default":{"outputSourceFiles":true}};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">pixi-svg</a></h3>
    <button id="menuToggle" class="btn btn-link btn-lg menu-toggle">
        <span class="glyphicon glyphicon-menu-hamburger"></span>
    </button>
    <div class="search">
        <input id="search" type="text" class="form-control input-md" placeholder="Search...">
    </div>
    <ul class="list">
    
    
        <li class="item" data-name="PIXI.SVG">
            <span class="title  ">
                
                
                    <a href="PIXI.SVG.html">PIXI.SVG</a>
                
            </span>
            
            <ul class="members itemMembers">
            
            </ul>
            
            <ul class="typedefs itemMembers">
            
            </ul>
            
            <ul class="typedefs itemMembers">
            
            </ul>
            
            <ul class="methods itemMembers">
            
            </ul>
            
            <ul class="events itemMembers">
            
            </ul>
            
        </li>
    
    </ul>
</div>

    <div class="main">
        <h1 class="page-title" data-filename="-_Users_mattkarl_GitHub_bigtimebuddy_pixi-svg_src_SVG.js.html">Source: /Users/mattkarl/GitHub/bigtimebuddy/pixi-svg/src/SVG.js</h1>
        


    
    <section>
        <header>
            <div class="header content-size">
                <h2>/Users/mattkarl/GitHub/bigtimebuddy/pixi-svg/src/SVG.js</h2>
            </div>
        </header>
        <article>
            <pre id="source-code" class="prettyprint source linenums"><code>import { Graphics } from '@pixi/graphics';
import { dPathParser } from './dPathParser';

/**
 * Scalable Graphics drawn from SVG image document.
 * @class SVG
 * @extends PIXI.Graphics
 * @memberof PIXI
 * @param {SVGSVGElement} svg - SVG Element `&lt;svg>`
 */
class SVG extends Graphics
{
    constructor(svg)
    {
        super();
        this._svgFill(svg);
        this._svgChildren(svg.children);
    }

    /**
     * Create a PIXI Graphic from SVG element
     * @private
     * @method
     * @param {Array&lt;*>} children - Collection of SVG nodes
     * @param {Boolean} [inherit=false] Whether to inherit fill settings.
     */
    _svgChildren(children, inherit = false)
    {
        for (let i = 0; i &lt; children.length; i++)
        {
            const child = children[i];

            this._svgFill(child, inherit);
            switch (child.nodeName.toLowerCase())
            {
                case 'path': {
                    this.svgPath(child);
                    break;
                }
                case 'circle':
                case 'ellipse': {
                    this.svgCircle(child);
                    break;
                }
                case 'rect': {
                    this.svgRect(child);
                    break;
                }
                case 'polygon': {
                    this.svgPoly(child, true);
                    break;
                }
                case 'polyline': {
                    this.svgPoly(child);
                    break;
                }
                case 'g': {
                    break;
                }
                default: {
                    // @if DEBUG
                    // eslint-disable-next-line no-console
                    console.info(`[PIXI.SVG] &lt;${child.nodeName}> elements unsupported`);
                    // @endif
                    break;
                }
            }
            this._svgChildren(child.children, true);
        }
    }

    /**
     * Convert the Hexidecimal string (e.g., "#fff") to uint
     * @private
     * @method
     */
    _hexToUint(hex)
    {
        if (hex[0] === '#')
        {
            // Remove the hash
            hex = hex.substr(1);

            // Convert shortcolors fc9 to ffcc99
            if (hex.length === 3)
            {
                hex = hex.replace(/([a-f0-9])/ig, '$1$1');
            }

            return parseInt(hex, 16);
        }

        const measureColor = SVG.measureColor;

        measureColor.style.color = hex;
        const rgb = window.getComputedStyle(document.body.appendChild(measureColor)).color
            .match(/\d+/g)
            .map((a) => parseInt(a, 10));

        document.body.removeChild(measureColor);

        return (rgb[0] &lt;&lt; 16) + (rgb[1] &lt;&lt; 8) + rgb[2];
    }

    /**
     * Render a &lt;ellipse> element or &lt;circle> element
     * @private
     * @method
     * @param {SVGCircleElement} node
     */
    svgCircle(node)
    {
        let heightProp = 'r';
        let widthProp = 'r';
        const isEllipse = node.nodeName === 'elipse';

        if (isEllipse)
        {
            heightProp += 'x';
            widthProp += 'y';
        }
        const width = parseFloat(node.getAttribute(widthProp));
        const height = parseFloat(node.getAttribute(heightProp));
        const cx = node.getAttribute('cx');
        const cy = node.getAttribute('cy');
        let x = 0;
        let y = 0;

        if (cx !== null)
        {
            x = parseFloat(cx);
        }
        if (cy !== null)
        {
            y = parseFloat(cy);
        }
        if (!isEllipse)
        {
            this.drawCircle(x, y, width);
        }
        else
        {
            this.drawEllipse(x, y, width, height);
        }
    }

    /**
     * Render a &lt;rect> element
     * @private
     * @method
     * @param {SVGRectElement} node
     */
    svgRect(node)
    {
        const x = parseFloat(node.getAttribute('x'));
        const y = parseFloat(node.getAttribute('y'));
        const width = parseFloat(node.getAttribute('width'));
        const height = parseFloat(node.getAttribute('height'));
        const rx = parseFloat(node.getAttribute('rx'));

        if (rx)
        {
            this.drawRoundedRect(
                x,
                y,
                width,
                height,
                rx,
            );
        }
        else
        {
            this.drawRect(
                x,
                y,
                width,
                height,
            );
        }
    }

    /**
     * Get the style property and parse options.
     * @private
     * @method
     * @param {SVGElement} node
     * @return {Object} Style attributes
     */
    svgStyle(node)
    {
        const style = node.getAttribute('style');
        const result = {
            fill: node.getAttribute('fill'),
            opacity: node.getAttribute('opacity'),
            stroke: node.getAttribute('stroke'),
            strokeWidth: node.getAttribute('stroke-width'),
        };

        if (style !== null)
        {
            style.split(';').forEach((prop) =>
            {
                const [name, value] = prop.split(':');

                if (name)
                {
                    result[name.trim()] = value.trim();
                }
            });
            if (result['stroke-width'])
            {
                result.strokeWidth = result['stroke-width'];
                delete result['stroke-width'];
            }
        }

        return result;
    }

    /**
     * Render a polyline element.
     * @private
     * @method
     * @param {SVGPolylineElement} node
     */
    svgPoly(node, close)
    {
        const points = node.getAttribute('points')
            .split(/[ ,]/g)
            .map((p) => parseInt(p, 10));

        this.drawPolygon(points);

        if (close)
        {
            this.closePath();
        }
    }

    /**
     * Set the fill and stroke style.
     * @private
     * @method
     * @param {SVGElement} node
     * @param {Boolean} inherit
     */
    _svgFill(node, inherit)
    {
        const { fill, opacity, stroke, strokeWidth } = this.svgStyle(node);
        const defaultLineWidth = stroke !== null ? 1 : 0;
        const lineWidth = strokeWidth !== null ? parseFloat(strokeWidth) : defaultLineWidth;
        const lineColor = stroke !== null ? this._hexToUint(stroke) : this.lineColor;

        if (fill)
        {
            if (fill === 'none')
            {
                this.beginFill(0, 0);
            }
            else
            {
                this.beginFill(
                    this._hexToUint(fill),
                    opacity !== null ? parseFloat(opacity) : 1,
                );
            }
        }
        else if (!inherit)
        {
            this.beginFill(0);
        }
        this.lineStyle(
            lineWidth,
            lineColor,
        );

        // @if DEBUG
        if (node.getAttribute('stroke-linejoin'))
        {
            // eslint-disable-next-line no-console
            console.info('[PIXI.SVG] "stroke-linejoin" attribute is not supported');
        }
        if (node.getAttribute('stroke-linecap'))
        {
            // eslint-disable-next-line no-console
            console.info('[PIXI.SVG] "stroke-linecap" attribute is not supported');
        }
        if (node.getAttribute('fill-rule'))
        {
            // eslint-disable-next-line no-console
            console.info('[PIXI.SVG] "fill-rule" attribute is not supported');
        }
        // @endif
    }

    /**
     * Render a &lt;path> d element
     * @method
     * @param {SVGPathElement} node
     */
    svgPath(node)
    {
        const d = node.getAttribute('d');
        let x; let
            y;
        const commands = dPathParser(d);

        for (let i = 0; i &lt; commands.length; i++)
        {
            const command = commands[i];

            switch (command.code)
            {
                case 'm': {
                    this.moveTo(
                        x += command.end.x,
                        y += command.end.y,
                    );
                    break;
                }
                case 'M': {
                    this.moveTo(
                        x = command.end.x,
                        y = command.end.y,
                    );
                    break;
                }
                case 'H': {
                    this.lineTo(x = command.value, y);
                    break;
                }
                case 'h': {
                    this.lineTo(x += command.value, y);
                    break;
                }
                case 'V': {
                    this.lineTo(x, y = command.value);
                    break;
                }
                case 'v': {
                    this.lineTo(x, y += command.value);
                    break;
                }
                case 'Z': {
                    this.closePath();
                    break;
                }
                case 'L': {
                    this.lineTo(
                        x = command.end.x,
                        y = command.end.y,
                    );
                    break;
                }
                case 'l': {
                    this.lineTo(
                        x += command.end.x,
                        y += command.end.y,
                    );
                    break;
                }
                case 'C': {
                    this.bezierCurveTo(
                        command.cp1.x,
                        command.cp1.y,
                        command.cp2.x,
                        command.cp2.y,
                        x = command.end.x,
                        y = command.end.y,
                    );
                    break;
                }
                case 'c': {
                    const currX = x;
                    const currY = y;

                    this.bezierCurveTo(
                        currX + command.cp1.x,
                        currY + command.cp1.y,
                        currX + command.cp2.x,
                        currY + command.cp2.y,
                        x += command.end.x,
                        y += command.end.y,
                    );
                    break;
                }
                case 's':
                case 'q': {
                    const currX = x;
                    const currY = y;

                    this.quadraticCurveTo(
                        currX + command.cp.x,
                        currY + command.cp.y,
                        x += command.end.x,
                        y += command.end.y,
                    );
                    break;
                }
                case 'S':
                case 'Q': {
                    this.quadraticCurveTo(
                        command.cp.x,
                        command.cp.y,
                        x = command.end.x,
                        y = command.end.y,
                    );
                    break;
                }
                default: {
                    // @if DEBUG
                    // eslint-disable-next-line no-console
                    console.info('[PIXI.SVG] Draw command not supported:', command.code, command);
                    // @endif
                    break;
                }
            }
        }
    }
}

/**
 * &lt;div> element to measure string colors like "black"
 * and convert to hex colors
 * @private
 */
SVG.measureColor = document.createElement('div');

export { SVG };

</code></pre>
        </article>
    </section>






        

        <footer class="content-size">
            <div class="footer">
                Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Thu Apr 23 2020 11:23:29 GMT-0700 (Pacific Daylight Time)
            </div>
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/main.js"></script>


</body>
</html>
