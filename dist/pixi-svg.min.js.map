{"version":3,"sources":["node_modules/pixify/node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/d-path-parser/parser.js","index.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiSvg","min","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","root","factory","dPathParse","d","makeCommand","obj","cmd","relative","get","what","must","re","lastIndex","index","res","exec","getSequence","matched","sequence","matchers","push","command","number","comma","flag","coordinate pair","x","y","arc definition","radii","rotation","large","clockwise","end","commands","upcmd","toUpperCase","map","coords","reduce","seq","rest","cp1","cp","value","apply","_dPathParser","SVGUtils","from","svg","resolution","arguments","undefined","graphic","PIXI","Graphics","fill","parseChildren","children","inherit","child","nodeName","toLowerCase","drawPath","drawCircle","drawEllipse","drawRect","drawPolygon","console","info","hexToUint","hex","substr","replace","parseInt","div","document","createElement","style","color","rgb","getComputedStyle","body","appendChild","match","removeChild","circleNode","internalEllipse","ellipseNode","node","wName","hName","width","parseFloat","getAttribute","height","cx","cy","rectNode","rx","drawRoundedRect","opacity","stroke","strokeWidth","lineWidth","lineColor","beginFill","lineStyle","pathNode","_dPathParser2","default","moveTo","lineTo","closePath","currX","currY","bezierCurveTo","cp2","_currX","_currY","_currX2","_currY2","quadraticCurveTo","_currX3","_currY3"],"mappings":"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","file":"pixi-svg.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*!\n * d-path-parser - v1.0.0\n * by Massimo Artizzu (MaxArt2501)\n *\n * https://github.com/MaxArt2501/d-path-parser\n *\n * Licensed under the MIT License\n * See LICENSE for details\n */\n\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof exports === \"object\") {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.dPathParse = factory();\n    }\n})(this, function() {\n\"use strict\";\n\nreturn function parse(d) {\n    var re = {\n        command: /\\s*([achlmqstvz])/gi,\n        number: /\\s*([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/gi,\n        comma: /\\s*(?:(,)|\\s)/g,\n        flag: /\\s*([01])/g\n    };\n    var matchers = {\n        \"number\": function(must) {\n            return +get(\"number\", must);\n        },\n        \"coordinate pair\": function(must) {\n            var x = get(\"number\", must);\n            if (x === null && !must) return null;\n            get(\"comma\");\n            var y = get(\"number\", true);\n            return { x: +x, y: +y };\n        },\n        \"arc definition\": function(must) {\n            var radii = matchers[\"coordinate pair\"](must);\n            if (!radii && !must) return null;\n            get(\"comma\");\n            var rotation = +get(\"number\", true);\n            get(\"comma\", true);\n            var large = !!+get(\"flag\", true);\n            get(\"comma\");\n            var clockwise = !!+get(\"flag\", true);\n            get(\"comma\");\n            var end = matchers[\"coordinate pair\"](true);\n            return {\n                radii: radii,\n                rotation: rotation,\n                large: large,\n                clockwise: clockwise,\n                end: end\n            };\n        }\n    }\n    var index = 0;\n    var commands = [];\n\n    while (index < d.length) {\n        var cmd = get(\"command\");\n        var upcmd = cmd.toUpperCase();\n        var relative = cmd !== upcmd;\n        var sequence;\n        switch (upcmd) {\n            case \"M\":\n                sequence = getSequence(\"coordinate pair\").map(function(coords, i) {\n                    if (i === 1) cmd = relative ? \"l\" : \"L\";\n                    return makeCommand({ end: coords });\n                });\n                break;\n            case \"L\":\n            case \"T\":\n                sequence = getSequence(\"coordinate pair\").map(function(coords) {\n                    return makeCommand({ end: coords });\n                });\n                break;\n            case \"C\":\n                sequence = getSequence(\"coordinate pair\");\n                if (sequence.length % 3)\n                    throw Error(\"Expected coordinate pair triplet at position \" + index);\n\n                sequence = sequence.reduce(function(seq, coords, i) {\n                    var rest = i % 3;\n                    if (!rest) {\n                        seq.push(makeCommand({ cp1: coords }));\n                    } else {\n                        var last = seq[seq.length - 1];\n                        last[rest === 1 ? \"cp2\" : \"end\"] = coords;\n                    }\n                    return seq;\n                }, []);\n\n                break;\n            case \"Q\":\n            case \"S\":\n                sequence = getSequence(\"coordinate pair\");\n                if (sequence.length & 1)\n                    throw Error(\"Expected coordinate pair couple at position \" + index);\n\n                sequence = sequence.reduce(function(seq, coords, i) {\n                    var odd = i & 1;\n                    if (!odd) {\n                        seq.push(makeCommand({ cp: coords }));\n                    } else {\n                        var last = seq[seq.length - 1];\n                        last.end = coords;\n                    }\n                    return seq;\n                }, []);\n\n                break;\n            case \"H\":\n            case \"V\":\n                sequence = getSequence(\"number\").map(function(value) {\n                    return makeCommand({ value: value });\n                });\n                break;\n            case \"A\":\n                sequence = getSequence(\"arc definition\").map(makeCommand);\n                break;\n            case \"Z\":\n                sequence = [ { code: \"Z\" } ];\n                break;\n        }\n        commands.push.apply(commands, sequence);\n    }\n\n    return commands;\n\n    function makeCommand(obj) {\n        obj.code = cmd;\n        obj.relative = relative;\n\n        return obj;\n    }\n    function get(what, must) {\n        re[what].lastIndex = index;\n        var res = re[what].exec(d);\n        if (!res || res.index !== index) {\n            if (!must) return null;\n            throw Error(\"Expected \" + what + \" at position \" + index);\n        }\n\n        index = re[what].lastIndex;\n\n        return res[1];\n    }\n    function getSequence(what) {\n        var sequence = [];\n        var matched;\n        var must = true;\n        while (matched = matchers[what](must)) {\n            sequence.push(matched);\n            must = !!get(\"comma\");\n        }\n\n        return sequence;\n    }\n};\n});\n","import dPathParse from 'd-path-parser';\n\n/**\n * Render SVG as Graphics\n * @class SVGUtils\n * @memberof PIXI\n */\nexport default class SVGUtils {\n    /**\n     * Create a PIXI Graphic from SVG element\n     * @static\n     * @method PIXI.SVGUtils.from\n     * @param {SVGSVGElement} svg - SVG Element\n     * @param {Number} [resolution=1] - Default resolution\n     * @param {PIXI.Graphics} [graphic=null] - Graphic to use, or else create a new one.\n     */\n    static from (svg, resolution = 1, graphic = null) {\n        if (!graphic) {\n            graphic = new PIXI.Graphics();\n        }\n        this.fill(graphic, svg, resolution);\n        this.parseChildren(graphic, svg.children, resolution);\n        return graphic;\n    }\n\n    /**\n     * Create a PIXI Graphic from SVG element\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.parseChildren\n     * @param {Array<*>} children - Collection of SVG nodes\n     * @param {Number} resolution - Default resolution\n     * @param {PIXI.Graphics} graphic - Graphic to use, or else create a new one.\n     */\n    static parseChildren (graphic, children, resolution, inherit = false) {\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            this.fill(graphic, child, resolution, inherit);\n            switch (child.nodeName.toLowerCase()) {\n                case 'path': {\n                    this.drawPath(graphic, child, resolution);\n                    break;\n                }\n                case 'circle': {\n                    this.drawCircle(graphic, child, resolution);\n                    break;\n                }\n                case 'ellipse': {\n                    this.drawEllipse(graphic, child, resolution);\n                    break;\n                }\n                case 'rect': {\n                    this.drawRect(graphic, child, resolution);\n                    break;\n                }\n                case 'polyline': {\n                    this.drawPolygon(graphic, child, resolution);\n                    break;\n                }\n                case 'g': {\n                    break;\n                }\n                default: {\n                    console.info('[SVGUtils] <%s> elements unsupported', child.nodeName);\n                    break;\n                }\n            }\n            this.parseChildren(graphic, child.children, resolution, true);\n        }\n    }\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.hexToUint\n     */\n    static hexToUint (hex) {\n        if (hex[0] === '#') {\n                        // Remove the hash\n            hex = hex.substr(1);\n\n                        // Convert shortcolors fc9 to ffcc99\n            if (hex.length === 3) {\n                hex = hex.replace(/([a-f0-9])/ig, '$1$1');\n            }\n            return parseInt(hex, 16);\n        } else {\n            const div = document.createElement('div');\n            div.style.color = hex;\n            const rgb = window.getComputedStyle(document.body.appendChild(div)).color\n                .match(/\\d+/g)\n                .map(function (a) {\n                    return parseInt(a, 10);\n                });\n            document.body.removeChild(div);\n            return (rgb[0] << 16) + (rgb[1] << 8) + rgb[2];\n        }\n    }\n\n    /**\n     * Render a <circle> element\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.drawCircle\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGCircleElement} circleNode\n     * @param {Number} resolution\n     */\n    static drawCircle (graphic, circleNode, resolution) {\n        this.internalEllipse(graphic, circleNode, 'r', 'r', resolution);\n    }\n\n    /**\n     * Render a <ellipse> element\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.drawEllipse\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGCircleElement} ellipseNode\n     * @param {Number} resolution\n     */\n    static drawEllipse (graphic, ellipseNode, resolution) {\n        this.internalEllipse(graphic, ellipseNode, 'rx', 'ry', resolution);\n    }\n\n    /**\n     * Render a <ellipse> element or <circle> element\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.internalEllipse\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGCircleElement} node\n     * @param {Number} wName Width name property\n     * @param {Number} hName Height name property\n     * @param {Number} resolution\n     */\n    static internalEllipse (graphic, node, wName, hName, resolution) {\n        const width = parseFloat(node.getAttribute(wName)) * resolution;\n        const height = parseFloat(node.getAttribute(hName)) * resolution;\n        const cx = node.getAttribute('cx');\n        const cy = node.getAttribute('cy');\n        let x = 0;\n        let y = 0;\n        if (cx !== null) {\n            x = parseFloat(cx) * resolution;\n        }\n        if (cy !== null) {\n            y = parseFloat(cy) * resolution;\n        }\n        graphic.drawEllipse(x, y, width, height);\n    }\n\n    /**\n     * Render a <rect> element\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.drawRect\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGRectElement} rectNode\n     * @param {Number} resolution\n     */\n    static drawRect (graphic, rectNode, resolution) {\n        const x = parseFloat(rectNode.getAttribute('x'));\n        const y = parseFloat(rectNode.getAttribute('y'));\n        const width = parseFloat(rectNode.getAttribute('width'));\n        const height = parseFloat(rectNode.getAttribute('height'));\n        const rx = parseFloat(rectNode.getAttribute('rx'));\n        if (rx) {\n            graphic.drawRoundedRect(\n                x * resolution,\n                y * resolution,\n                width * resolution,\n                height * resolution,\n                rx * resolution\n            );\n        } else {\n            graphic.drawRect(\n                x * resolution,\n                y * resolution,\n                width * resolution,\n                height * resolution\n            );\n        }\n    }\n\n    /**\n     * Set the fill and stroke style.\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.fill\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGElement} node\n     * @param {Number} resolution\n     * @param {Boolean} inherit\n     */\n    static fill (graphic, node, resolution, inherit) {\n        const fill = node.getAttribute('fill');\n        const opacity = node.getAttribute('opacity');\n        const stroke = node.getAttribute('stroke');\n        const strokeWidth = node.getAttribute('stroke-width');\n        const lineWidth = strokeWidth !== null ? parseFloat(strokeWidth) : 0;\n        const lineColor = stroke !== null ? this.hexToUint(stroke) : graphic.lineColor;\n        if (fill) {\n            if (fill === 'none') {\n                graphic.beginFill(0, 0);\n            } else {\n                graphic.beginFill(\n                    this.hexToUint(fill),\n                    opacity !== null ? parseFloat(opacity) : 1\n                );\n            }\n        } else if (!inherit) {\n            graphic.beginFill(0);\n        }\n        graphic.lineStyle(\n            lineWidth * resolution,\n            lineColor\n        );\n\n        if (node.getAttribute('stroke-linejoin')) {\n            console.info('[SVGUtils] \"stroke-linejoin\" attribute is not supported');\n        }\n        if (node.getAttribute('stroke-linecap')) {\n            console.info('[SVGUtils] \"stroke-linecap\" attribute is not supported');\n        }\n        if (node.getAttribute('fill-rule')) {\n            console.info('[SVGUtils] \"fill-rule\" attribute is not supported');\n        }\n    }\n\n    /**\n     * Render a <path> d element\n     * @static\n     * @method PIXI.SVGUtils.drawPath\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGPathElement} pathNode\n     * @param {Number} resolution\n     */\n    static drawPath (graphic, pathNode, resolution) {\n        const d = pathNode.getAttribute('d');\n        let x, y;\n        const commands = dPathParse(d);\n        for (var i = 0; i < commands.length; i++) {\n            const command = commands[i];\n            switch (command.code) {\n                case 'm': {\n                    graphic.moveTo(\n                        x += command.end.x * resolution,\n                        y += command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'M': {\n                    graphic.moveTo(\n                        x = command.end.x * resolution,\n                        y = command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'H': {\n                    graphic.lineTo(x = command.value * resolution, y);\n                    break;\n                }\n                case 'h': {\n                    graphic.lineTo(x += command.value * resolution, y);\n                    break;\n                }\n                case 'V': {\n                    graphic.lineTo(x, y = command.value * resolution);\n                    break;\n                }\n                case 'v': {\n                    graphic.lineTo(x, y += command.value * resolution);\n                    break;\n                }\n                case 'Z': {\n                    graphic.closePath();\n                    break;\n                }\n                case 'L': {\n                    graphic.lineTo(\n                        x = command.end.x * resolution,\n                        y = command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'l': {\n                    graphic.lineTo(\n                        x += command.end.x * resolution,\n                        y += command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'C': {\n                    const currX = x;\n                    const currY = y;\n                    graphic.bezierCurveTo(\n                        currX + command.cp1.x * resolution,\n                        currY + command.cp1.y * resolution,\n                        currX + command.cp2.x * resolution,\n                        currY + command.cp2.y * resolution,\n                        x = command.end.x * resolution,\n                        y = command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'c': {\n                    const currX = x;\n                    const currY = y;\n                    graphic.bezierCurveTo(\n                        currX + command.cp1.x * resolution,\n                        currY + command.cp1.y * resolution,\n                        currX + command.cp2.x * resolution,\n                        currY + command.cp2.y * resolution,\n                        x += command.end.x * resolution,\n                        y += command.end.y * resolution\n                    );\n                    break;\n                }\n                case 's':\n                case 'q': {\n                    const currX = x;\n                    const currY = y;\n                    graphic.quadraticCurveTo(\n                        currX + command.cp.x * resolution,\n                        currY + command.cp.y * resolution,\n                        x += command.end.x * resolution,\n                        y += command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'S':\n                case 'Q': {\n                    const currX = x;\n                    const currY = y;\n                    graphic.quadraticCurveTo(\n                        currX + command.cp.x * resolution,\n                        currY + command.cp.y * resolution,\n                        x = command.end.x * resolution,\n                        y = command.end.y * resolution\n                    );\n                    break;\n                }\n                default: {\n                    console.info('[SVGUtils] Draw command not supported:', command.code, command);\n                    break;\n                }\n            }\n        }\n    }\n}\n\n// Assign to global pixi object\nPIXI.SVGUtils = SVGUtils;\n"],"sourceRoot":"."}