{"version":3,"sources":["node_modules/pixify/node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/d-path-parser/parser.js","index.js"],"names":[],"mappings":";;;;;;;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACzKA;;;;;;;;AAEA;;;;;IAKqB;;;;;AACjB;;;;;;;;aAQO,qBAAM,KAAqC;AAAA,YAAhC,UAAgC,uEAAnB,CAAmB;AAAA,YAAhB,OAAgB,uEAAN,IAAM;;AAC9C,YAAI,CAAC,OAAL,EAAc;AACV,sBAAU,IAAI,KAAK,QAAT,EAAV;AACH;AACD,aAAK,IAAL,CAAU,OAAV,EAAmB,GAAnB,EAAwB,UAAxB;AACA,aAAK,aAAL,CAAmB,OAAnB,EAA4B,IAAI,QAAhC,EAA0C,UAA1C;AACA,eAAO,OAAP;AACH;;AAED;;;;;;;;;;;aASO,uCAA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","file":"pixi-svg.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*!\n * d-path-parser - v1.0.0\n * by Massimo Artizzu (MaxArt2501)\n *\n * https://github.com/MaxArt2501/d-path-parser\n *\n * Licensed under the MIT License\n * See LICENSE for details\n */\n\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof exports === \"object\") {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.dPathParse = factory();\n    }\n})(this, function() {\n\"use strict\";\n\nreturn function parse(d) {\n    var re = {\n        command: /\\s*([achlmqstvz])/gi,\n        number: /\\s*([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/gi,\n        comma: /\\s*(?:(,)|\\s)/g,\n        flag: /\\s*([01])/g\n    };\n    var matchers = {\n        \"number\": function(must) {\n            return +get(\"number\", must);\n        },\n        \"coordinate pair\": function(must) {\n            var x = get(\"number\", must);\n            if (x === null && !must) return null;\n            get(\"comma\");\n            var y = get(\"number\", true);\n            return { x: +x, y: +y };\n        },\n        \"arc definition\": function(must) {\n            var radii = matchers[\"coordinate pair\"](must);\n            if (!radii && !must) return null;\n            get(\"comma\");\n            var rotation = +get(\"number\", true);\n            get(\"comma\", true);\n            var large = !!+get(\"flag\", true);\n            get(\"comma\");\n            var clockwise = !!+get(\"flag\", true);\n            get(\"comma\");\n            var end = matchers[\"coordinate pair\"](true);\n            return {\n                radii: radii,\n                rotation: rotation,\n                large: large,\n                clockwise: clockwise,\n                end: end\n            };\n        }\n    }\n    var index = 0;\n    var commands = [];\n\n    while (index < d.length) {\n        var cmd = get(\"command\");\n        var upcmd = cmd.toUpperCase();\n        var relative = cmd !== upcmd;\n        var sequence;\n        switch (upcmd) {\n            case \"M\":\n                sequence = getSequence(\"coordinate pair\").map(function(coords, i) {\n                    if (i === 1) cmd = relative ? \"l\" : \"L\";\n                    return makeCommand({ end: coords });\n                });\n                break;\n            case \"L\":\n            case \"T\":\n                sequence = getSequence(\"coordinate pair\").map(function(coords) {\n                    return makeCommand({ end: coords });\n                });\n                break;\n            case \"C\":\n                sequence = getSequence(\"coordinate pair\");\n                if (sequence.length % 3)\n                    throw Error(\"Expected coordinate pair triplet at position \" + index);\n\n                sequence = sequence.reduce(function(seq, coords, i) {\n                    var rest = i % 3;\n                    if (!rest) {\n                        seq.push(makeCommand({ cp1: coords }));\n                    } else {\n                        var last = seq[seq.length - 1];\n                        last[rest === 1 ? \"cp2\" : \"end\"] = coords;\n                    }\n                    return seq;\n                }, []);\n\n                break;\n            case \"Q\":\n            case \"S\":\n                sequence = getSequence(\"coordinate pair\");\n                if (sequence.length & 1)\n                    throw Error(\"Expected coordinate pair couple at position \" + index);\n\n                sequence = sequence.reduce(function(seq, coords, i) {\n                    var odd = i & 1;\n                    if (!odd) {\n                        seq.push(makeCommand({ cp: coords }));\n                    } else {\n                        var last = seq[seq.length - 1];\n                        last.end = coords;\n                    }\n                    return seq;\n                }, []);\n\n                break;\n            case \"H\":\n            case \"V\":\n                sequence = getSequence(\"number\").map(function(value) {\n                    return makeCommand({ value: value });\n                });\n                break;\n            case \"A\":\n                sequence = getSequence(\"arc definition\").map(makeCommand);\n                break;\n            case \"Z\":\n                sequence = [ { code: \"Z\" } ];\n                break;\n        }\n        commands.push.apply(commands, sequence);\n    }\n\n    return commands;\n\n    function makeCommand(obj) {\n        obj.code = cmd;\n        obj.relative = relative;\n\n        return obj;\n    }\n    function get(what, must) {\n        re[what].lastIndex = index;\n        var res = re[what].exec(d);\n        if (!res || res.index !== index) {\n            if (!must) return null;\n            throw Error(\"Expected \" + what + \" at position \" + index);\n        }\n\n        index = re[what].lastIndex;\n\n        return res[1];\n    }\n    function getSequence(what) {\n        var sequence = [];\n        var matched;\n        var must = true;\n        while (matched = matchers[what](must)) {\n            sequence.push(matched);\n            must = !!get(\"comma\");\n        }\n\n        return sequence;\n    }\n};\n});\n","import dPathParse from 'd-path-parser';\n\n/**\n * Render SVG as Graphics\n * @class SVGUtils\n * @memberof PIXI\n */\nexport default class SVGUtils {\n    /**\n     * Create a PIXI Graphic from SVG element\n     * @static\n     * @method PIXI.SVGUtils.from\n     * @param {SVGSVGElement} svg - SVG Element\n     * @param {Number} [resolution=1] - Default resolution\n     * @param {PIXI.Graphics} [graphic=null] - Graphic to use, or else create a new one.\n     */\n    static from (svg, resolution = 1, graphic = null) {\n        if (!graphic) {\n            graphic = new PIXI.Graphics();\n        }\n        this.fill(graphic, svg, resolution);\n        this.parseChildren(graphic, svg.children, resolution);\n        return graphic;\n    }\n\n    /**\n     * Create a PIXI Graphic from SVG element\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.parseChildren\n     * @param {Array<*>} children - Collection of SVG nodes\n     * @param {Number} resolution - Default resolution\n     * @param {PIXI.Graphics} graphic - Graphic to use, or else create a new one.\n     */\n    static parseChildren (graphic, children, resolution, inherit = false) {\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            this.fill(graphic, child, resolution, inherit);\n            switch (child.nodeName.toLowerCase()) {\n                case 'path': {\n                    this.drawPath(graphic, child, resolution);\n                    break;\n                }\n                case 'circle': {\n                    this.drawCircle(graphic, child, resolution);\n                    break;\n                }\n                case 'ellipse': {\n                    this.drawEllipse(graphic, child, resolution);\n                    break;\n                }\n                case 'rect': {\n                    this.drawRect(graphic, child, resolution);\n                    break;\n                }\n                case 'polyline': {\n                    this.drawPolygon(graphic, child, resolution);\n                    break;\n                }\n                case 'g': {\n                    break;\n                }\n                default: {\n                    console.info('[SVGUtils] <%s> elements unsupported', child.nodeName);\n                    break;\n                }\n            }\n            this.parseChildren(graphic, child.children, resolution, true);\n        }\n    }\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.hexToUint\n     */\n    static hexToUint (hex) {\n        if (hex[0] === '#') {\n                        // Remove the hash\n            hex = hex.substr(1);\n\n                        // Convert shortcolors fc9 to ffcc99\n            if (hex.length === 3) {\n                hex = hex.replace(/([a-f0-9])/ig, '$1$1');\n            }\n            return parseInt(hex, 16);\n        } else {\n            const div = document.createElement('div');\n            div.style.color = hex;\n            const rgb = window.getComputedStyle(document.body.appendChild(div)).color\n                .match(/\\d+/g)\n                .map(function (a) {\n                    return parseInt(a, 10);\n                });\n            document.body.removeChild(div);\n            return (rgb[0] << 16) + (rgb[1] << 8) + rgb[2];\n        }\n    }\n\n    /**\n     * Render a <circle> element\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.drawCircle\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGCircleElement} circleNode\n     * @param {Number} resolution\n     */\n    static drawCircle (graphic, circleNode, resolution) {\n        this.internalEllipse(graphic, circleNode, 'r', 'r', resolution);\n    }\n\n    /**\n     * Render a <ellipse> element\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.drawEllipse\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGCircleElement} ellipseNode\n     * @param {Number} resolution\n     */\n    static drawEllipse (graphic, ellipseNode, resolution) {\n        this.internalEllipse(graphic, ellipseNode, 'rx', 'ry', resolution);\n    }\n\n    /**\n     * Render a <ellipse> element or <circle> element\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.internalEllipse\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGCircleElement} node\n     * @param {Number} wName Width name property\n     * @param {Number} hName Height name property\n     * @param {Number} resolution\n     */\n    static internalEllipse (graphic, node, wName, hName, resolution) {\n        const width = parseFloat(node.getAttribute(wName)) * resolution;\n        const height = parseFloat(node.getAttribute(hName)) * resolution;\n        const cx = node.getAttribute('cx');\n        const cy = node.getAttribute('cy');\n        let x = 0;\n        let y = 0;\n        if (cx !== null) {\n            x = parseFloat(cx) * resolution;\n        }\n        if (cy !== null) {\n            y = parseFloat(cy) * resolution;\n        }\n        graphic.drawEllipse(x, y, width, height);\n    }\n\n    /**\n     * Render a <rect> element\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.drawRect\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGRectElement} rectNode\n     * @param {Number} resolution\n     */\n    static drawRect (graphic, rectNode, resolution) {\n        const x = parseFloat(rectNode.getAttribute('x'));\n        const y = parseFloat(rectNode.getAttribute('y'));\n        const width = parseFloat(rectNode.getAttribute('width'));\n        const height = parseFloat(rectNode.getAttribute('height'));\n        const rx = parseFloat(rectNode.getAttribute('rx'));\n        if (rx) {\n            graphic.drawRoundedRect(\n                x * resolution,\n                y * resolution,\n                width * resolution,\n                height * resolution,\n                rx * resolution\n            );\n        } else {\n            graphic.drawRect(\n                x * resolution,\n                y * resolution,\n                width * resolution,\n                height * resolution\n            );\n        }\n    }\n\n    /**\n     * Set the fill and stroke style.\n     * @static\n     * @private\n     * @method PIXI.SVGUtils.fill\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGElement} node\n     * @param {Number} resolution\n     * @param {Boolean} inherit\n     */\n    static fill (graphic, node, resolution, inherit) {\n        const fill = node.getAttribute('fill');\n        const opacity = node.getAttribute('opacity');\n        const stroke = node.getAttribute('stroke');\n        const strokeWidth = node.getAttribute('stroke-width');\n        const lineWidth = strokeWidth !== null ? parseFloat(strokeWidth) : 0;\n        const lineColor = stroke !== null ? this.hexToUint(stroke) : graphic.lineColor;\n        if (fill) {\n            if (fill === 'none') {\n                graphic.beginFill(0, 0);\n            } else {\n                graphic.beginFill(\n                    this.hexToUint(fill),\n                    opacity !== null ? parseFloat(opacity) : 1\n                );\n            }\n        } else if (!inherit) {\n            graphic.beginFill(0);\n        }\n        graphic.lineStyle(\n            lineWidth * resolution,\n            lineColor\n        );\n\n        if (node.getAttribute('stroke-linejoin')) {\n            console.info('[SVGUtils] \"stroke-linejoin\" attribute is not supported');\n        }\n        if (node.getAttribute('stroke-linecap')) {\n            console.info('[SVGUtils] \"stroke-linecap\" attribute is not supported');\n        }\n        if (node.getAttribute('fill-rule')) {\n            console.info('[SVGUtils] \"fill-rule\" attribute is not supported');\n        }\n    }\n\n    /**\n     * Render a <path> d element\n     * @static\n     * @method PIXI.SVGUtils.drawPath\n     * @param {PIXI.Graphics} graphic\n     * @param {SVGPathElement} pathNode\n     * @param {Number} resolution\n     */\n    static drawPath (graphic, pathNode, resolution) {\n        const d = pathNode.getAttribute('d');\n        let x, y;\n        const commands = dPathParse(d);\n        for (var i = 0; i < commands.length; i++) {\n            const command = commands[i];\n            switch (command.code) {\n                case 'm': {\n                    graphic.moveTo(\n                        x += command.end.x * resolution,\n                        y += command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'M': {\n                    graphic.moveTo(\n                        x = command.end.x * resolution,\n                        y = command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'H': {\n                    graphic.lineTo(x = command.value * resolution, y);\n                    break;\n                }\n                case 'h': {\n                    graphic.lineTo(x += command.value * resolution, y);\n                    break;\n                }\n                case 'V': {\n                    graphic.lineTo(x, y = command.value * resolution);\n                    break;\n                }\n                case 'v': {\n                    graphic.lineTo(x, y += command.value * resolution);\n                    break;\n                }\n                case 'Z': {\n                    graphic.closePath();\n                    break;\n                }\n                case 'L': {\n                    graphic.lineTo(\n                        x = command.end.x * resolution,\n                        y = command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'l': {\n                    graphic.lineTo(\n                        x += command.end.x * resolution,\n                        y += command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'C': {\n                    const currX = x;\n                    const currY = y;\n                    graphic.bezierCurveTo(\n                        currX + command.cp1.x * resolution,\n                        currY + command.cp1.y * resolution,\n                        currX + command.cp2.x * resolution,\n                        currY + command.cp2.y * resolution,\n                        x = command.end.x * resolution,\n                        y = command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'c': {\n                    const currX = x;\n                    const currY = y;\n                    graphic.bezierCurveTo(\n                        currX + command.cp1.x * resolution,\n                        currY + command.cp1.y * resolution,\n                        currX + command.cp2.x * resolution,\n                        currY + command.cp2.y * resolution,\n                        x += command.end.x * resolution,\n                        y += command.end.y * resolution\n                    );\n                    break;\n                }\n                case 's':\n                case 'q': {\n                    const currX = x;\n                    const currY = y;\n                    graphic.quadraticCurveTo(\n                        currX + command.cp.x * resolution,\n                        currY + command.cp.y * resolution,\n                        x += command.end.x * resolution,\n                        y += command.end.y * resolution\n                    );\n                    break;\n                }\n                case 'S':\n                case 'Q': {\n                    const currX = x;\n                    const currY = y;\n                    graphic.quadraticCurveTo(\n                        currX + command.cp.x * resolution,\n                        currY + command.cp.y * resolution,\n                        x = command.end.x * resolution,\n                        y = command.end.y * resolution\n                    );\n                    break;\n                }\n                default: {\n                    console.info('[SVGUtils] Draw command not supported:', command.code, command);\n                    break;\n                }\n            }\n        }\n    }\n}\n\n// Assign to global pixi object\nPIXI.SVGUtils = SVGUtils;\n"],"sourceRoot":"."}