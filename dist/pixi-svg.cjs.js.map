{"version":3,"file":"pixi-svg.cjs.js","sources":["../src/SVG.js"],"sourcesContent":["import { Graphics } from '@pixi/graphics';\nimport dPathParser from 'd-path-parser';\nimport color from 'tinycolor2';\n\n/**\n * Scalable Graphics drawn from SVG image document.\n * @class SVG\n * @extends PIXI.Graphics\n * @memberof PIXI\n * @param {SVGSVGElement} svg - SVG Element `<svg>`\n */\nclass SVG extends Graphics\n{\n    constructor(svg)\n    {\n        super();\n        this._svgFill(svg);\n        this._svgChildren(svg.children);\n    }\n\n    /**\n     * Create a PIXI Graphic from SVG element\n     * @private\n     * @method\n     * @param {Array<*>} children - Collection of SVG nodes\n     * @param {Boolean} [inherit=false] Whether to inherit fill settings.\n     */\n    _svgChildren(children, inherit = false)\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            this._svgFill(child, inherit);\n            switch (child.nodeName.toLowerCase())\n            {\n                case 'path': {\n                    this._svgPath(child);\n                    break;\n                }\n                case 'circle':\n                case 'ellipse': {\n                    this._svgCircle(child);\n                    break;\n                }\n                case 'rect': {\n                    this._svgRect(child);\n                    break;\n                }\n                case 'polygon': {\n                    this._svgPoly(child, true);\n                    break;\n                }\n                case 'polyline': {\n                    this._svgPoly(child);\n                    break;\n                }\n                case 'g': {\n                    break;\n                }\n                default: {\n                    // eslint-disable-next-line no-console\n                    console.info(`[PIXI.SVG] <${child.nodeName}> elements unsupported`);\n                    break;\n                }\n            }\n            this._svgChildren(child.children, true);\n        }\n    }\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @private\n     * @method\n     */\n    _hexToUint(hex)\n    {\n        if (hex[0] === '#')\n        {\n            // Remove the hash\n            hex = hex.substr(1);\n\n            // Convert shortcolors fc9 to ffcc99\n            if (hex.length === 3)\n            {\n                hex = hex.replace(/([a-f0-9])/ig, '$1$1');\n            }\n\n            return parseInt(hex, 16);\n        }\n\n        const { r, g, b } = color(hex).toRgb();\n\n        return (r << 16) + (g << 8) + b;\n    }\n\n    /**\n     * Render a <ellipse> element or <circle> element\n     * @private\n     * @method\n     * @param {SVGCircleElement} node\n     */\n    _svgCircle(node)\n    {\n        let heightProp = 'r';\n        let widthProp = 'r';\n        const isEllipse = node.nodeName === 'elipse';\n\n        if (isEllipse)\n        {\n            heightProp += 'x';\n            widthProp += 'y';\n        }\n        const width = parseFloat(node.getAttribute(widthProp));\n        const height = parseFloat(node.getAttribute(heightProp));\n        const cx = node.getAttribute('cx');\n        const cy = node.getAttribute('cy');\n        let x = 0;\n        let y = 0;\n\n        if (cx !== null)\n        {\n            x = parseFloat(cx);\n        }\n        if (cy !== null)\n        {\n            y = parseFloat(cy);\n        }\n        if (!isEllipse)\n        {\n            this.drawCircle(x, y, width);\n        }\n        else\n        {\n            this.drawEllipse(x, y, width, height);\n        }\n    }\n\n    /**\n     * Render a <rect> element\n     * @private\n     * @method\n     * @param {SVGRectElement} node\n     */\n    _svgRect(node)\n    {\n        const x = parseFloat(node.getAttribute('x'));\n        const y = parseFloat(node.getAttribute('y'));\n        const width = parseFloat(node.getAttribute('width'));\n        const height = parseFloat(node.getAttribute('height'));\n        const rx = parseFloat(node.getAttribute('rx'));\n\n        if (rx)\n        {\n            this.drawRoundedRect(x, y, width, height, rx);\n        }\n        else\n        {\n            this.drawRect(x, y, width, height);\n        }\n    }\n\n    /**\n     * Get the style property and parse options.\n     * @private\n     * @method\n     * @param {SVGElement} node\n     * @return {Object} Style attributes\n     */\n    _svgStyle(node)\n    {\n        const style = node.getAttribute('style');\n        const result = {\n            fill: node.getAttribute('fill'),\n            opacity: node.getAttribute('opacity'),\n            stroke: node.getAttribute('stroke'),\n            strokeWidth: node.getAttribute('stroke-width'),\n            cap: node.getAttribute('stroke-linecap'),\n            join: node.getAttribute('stroke-linejoin'),\n            miterLimit: node.getAttribute('stroke-miterlimit'),\n        };\n\n        if (style !== null)\n        {\n            style.split(';').forEach((prop) =>\n            {\n                const [name, value] = prop.split(':');\n\n                if (name)\n                {\n                    result[name.trim()] = value.trim();\n                }\n            });\n            if (result['stroke-width'])\n            {\n                result.strokeWidth = result['stroke-width'];\n                delete result['stroke-width'];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Render a polyline element.\n     * @private\n     * @method\n     * @param {SVGPolylineElement} node\n     */\n    _svgPoly(node, close)\n    {\n        const points = node.getAttribute('points')\n            .split(/[ ,]/g)\n            .map((p) => parseInt(p, 10));\n\n        this.drawPolygon(points);\n\n        if (close)\n        {\n            this.closePath();\n        }\n    }\n\n    /**\n     * Set the fill and stroke style.\n     * @private\n     * @method\n     * @param {SVGElement} node\n     * @param {Boolean} inherit\n     */\n    _svgFill(node, inherit)\n    {\n        const { fill, opacity, stroke, strokeWidth, cap, join, miterLimit } = this._svgStyle(node);\n        const defaultLineWidth = stroke !== null ? 1 : 0;\n        const lineWidth = strokeWidth !== null ? parseFloat(strokeWidth) : defaultLineWidth;\n        const lineColor = stroke !== null ? this._hexToUint(stroke) : this.lineColor;\n\n        if (fill)\n        {\n            if (fill === 'none')\n            {\n                this.beginFill(0, 0);\n            }\n            else\n            {\n                this.beginFill(\n                    this._hexToUint(fill),\n                    opacity !== null ? parseFloat(opacity) : 1,\n                );\n            }\n        }\n        else if (!inherit)\n        {\n            this.beginFill(0);\n        }\n\n        this.lineStyle({\n            width: stroke === null && strokeWidth === null && inherit ? this.line.width : lineWidth,\n            color: stroke === null && inherit ? this.line.color : lineColor,\n            cap: cap === null && inherit ? this.line.cap : cap,\n            join: join === null && inherit ? this.line.join : join,\n            miterLimit: miterLimit === null && inherit ? this.line.miterLimit : parseFloat(miterLimit),\n        });\n\n        if (node.getAttribute('fill-rule'))\n        {\n            // eslint-disable-next-line no-console\n            console.info('[PIXI.SVG] \"fill-rule\" attribute is not supported');\n        }\n    }\n\n    /**\n     * Render a <path> d element\n     * @method\n     * @param {SVGPathElement} node\n     */\n    _svgPath(node)\n    {\n        const d = node.getAttribute('d');\n        let x; let\n            y;\n        const commands = dPathParser(d);\n\n        for (let i = 0; i < commands.length; i++)\n        {\n            const command = commands[i];\n\n            switch (command.code)\n            {\n                case 'm': {\n                    this.moveTo(\n                        x += command.end.x,\n                        y += command.end.y,\n                    );\n                    break;\n                }\n                case 'M': {\n                    this.moveTo(\n                        x = command.end.x,\n                        y = command.end.y,\n                    );\n                    break;\n                }\n                case 'H': {\n                    this.lineTo(x = command.value, y);\n                    break;\n                }\n                case 'h': {\n                    this.lineTo(x += command.value, y);\n                    break;\n                }\n                case 'V': {\n                    this.lineTo(x, y = command.value);\n                    break;\n                }\n                case 'v': {\n                    this.lineTo(x, y += command.value);\n                    break;\n                }\n                case 'Z': {\n                    this.closePath();\n                    break;\n                }\n                case 'L': {\n                    this.lineTo(\n                        x = command.end.x,\n                        y = command.end.y,\n                    );\n                    break;\n                }\n                case 'l': {\n                    this.lineTo(\n                        x += command.end.x,\n                        y += command.end.y,\n                    );\n                    break;\n                }\n                case 'C': {\n                    this.bezierCurveTo(\n                        command.cp1.x,\n                        command.cp1.y,\n                        command.cp2.x,\n                        command.cp2.y,\n                        x = command.end.x,\n                        y = command.end.y,\n                    );\n                    break;\n                }\n                case 'c': {\n                    const currX = x;\n                    const currY = y;\n\n                    this.bezierCurveTo(\n                        currX + command.cp1.x,\n                        currY + command.cp1.y,\n                        currX + command.cp2.x,\n                        currY + command.cp2.y,\n                        x += command.end.x,\n                        y += command.end.y,\n                    );\n                    break;\n                }\n                case 's':\n                case 'q': {\n                    const currX = x;\n                    const currY = y;\n\n                    this.quadraticCurveTo(\n                        currX + command.cp.x,\n                        currY + command.cp.y,\n                        x += command.end.x,\n                        y += command.end.y,\n                    );\n                    break;\n                }\n                case 'S':\n                case 'Q': {\n                    this.quadraticCurveTo(\n                        command.cp.x,\n                        command.cp.y,\n                        x = command.end.x,\n                        y = command.end.y,\n                    );\n                    break;\n                }\n                default: {\n                    // eslint-disable-next-line no-console\n                    console.info('[PIXI.SVG] Draw command not supported:', command.code, command);\n                    break;\n                }\n            }\n        }\n    }\n}\n\nexport { SVG };\n"],"names":["SVG","svg","super","this","_svgFill","_svgChildren","children","inherit","let","i","length","const","child","nodeName","toLowerCase","_svgPath","_svgCircle","_svgRect","_svgPoly","console","info","_hexToUint","hex","substr","replace","parseInt","color","toRgb","node","heightProp","widthProp","isEllipse","width","parseFloat","getAttribute","height","cx","cy","x","y","drawEllipse","drawCircle","rx","drawRoundedRect","drawRect","_svgStyle","style","result","fill","opacity","stroke","strokeWidth","cap","join","miterLimit","split","forEach","prop","name","trim","value","close","points","map","p","drawPolygon","closePath","defaultLineWidth","lineWidth","lineColor","beginFill","lineStyle","line","d","commands","dPathParser","command","code","moveTo","end","lineTo","bezierCurveTo","cp1","cp2","currX","currY","quadraticCurveTo","cp","Graphics"],"mappings":"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"}